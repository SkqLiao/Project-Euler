# Project Euler 11-20 题解

## Problem 11. [Largest product in a grid](https://projecteuler.net/problem=11)

求在下列 $20\times 20$ 的数字矩阵中，找到连续的四个数（横、竖、对角）使其乘积最大。

`08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08`
`49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00`
`81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65`
`52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91`
`22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80`
`24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50`
`32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70`
`67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21`
`24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72`
`21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95`
`78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92`
`16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57`
`86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58`
`19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40`
`04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66`
`88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69`
`04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36`
`20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16`
`20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54`
`01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48`

似乎只能枚举。

```cpp
#include <bits/stdc++.h>

int A[20][20] = {
{8, 2, 22, 97, 38, 15, 0, 40, 0, 75, 4, 5, 7, 78, 52, 12, 50, 77, 91, 8},
{49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 4, 56, 62, 0},
{81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 3, 49, 13, 36, 65},
{52, 70, 95, 23, 4, 60, 11, 42, 69, 24, 68, 56, 1, 32, 56, 71, 37, 2, 36, 91},
{22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80},
{24, 47, 32, 60, 99, 3, 45, 2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50},
{32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70},
{67, 26, 20, 68, 2, 62, 12, 20, 95, 63, 94, 39, 63, 8, 40, 91, 66, 49, 94, 21},
{24, 55, 58, 5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72},
{21, 36, 23, 9, 75, 0, 76, 44, 20, 45, 35, 14, 0, 61, 33, 97, 34, 31, 33, 95},
{78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 3, 80, 4, 62, 16, 14, 9, 53, 56, 92},
{16, 39, 5, 42, 96, 35, 31, 47, 55, 58, 88, 24, 0, 17, 54, 24, 36, 29, 85, 57},
{86, 56, 0, 48, 35, 71, 89, 7, 5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58},
{19, 80, 81, 68, 5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 4, 89, 55, 40},
{4, 52, 8, 83, 97, 35, 99, 16, 7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66},
{88, 36, 68, 87, 57, 62, 20, 72, 3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69},
{4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 8, 46, 29, 32, 40, 62, 76, 36},
{20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 4, 36, 16},
{20, 73, 35, 29, 78, 31, 90, 1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 5, 54},
{1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 1, 89, 19, 67, 48}};

int main() {
	int mx = 0;
	for (int i = 0; i < 20; ++i) {
		for (int j = 0; j <= 16; ++j) {
			int cur = 1;
			for (int k = j; k < j + 4; ++k)
				cur *= A[i][k];
			mx = std::max(mx, cur);
		}
	}
	for (int i = 0; i <= 16; ++i) {
		for (int j = 0; j < 20; ++j) {
			int cur = 1;
			for (int k = i; k < i + 4; ++k)
				cur *= A[k][j];
			mx = std::max(mx, cur);
		}
	}
	for (int i = 0; i <= 16; ++i) {
		for (int j = 0; j <= 16; ++j) {
			int cur = 1;
			for (int k = 0; k < 4; ++k)
				cur *= A[i + k][j + k];
			mx = std::max(mx, cur);
		}
	}
	for (int i = 3; i < 20; ++i) {
		for (int j = 3; j < 20; ++j) {
			int cur = 1;
			for (int k = 0; k < 4; ++k)
				cur *= A[i - k][j + k];
			mx = std::max(mx, cur);
		}
	}
	std::cout << mx << "\n";
	return 0;
}
```

Answer: **70600674**

## Problem 12. [Highly divisible triangular number](https://projecteuler.net/problem=12)

求最小的 $x$ ，满足 $x$ 有至少 $500$ 个因数，且 $x=\frac{n\times (n + 1)}{2}$。

任意数可被质因数分解，$x=p_1^{a_1}p_2^{a_2}\cdots p_n^{a_n}$，其因数个数为 $\prod{(a_i+1)}$。

而 $i$ 与 $i+1$ 互质，即两者没有相同的质因数数。因而 $i*(i+1)$ 的公因数个数为两数公因数个数之积。

显然相邻两数必有一个是 $2$ 的倍数，所以将偶数除以二后再计算因数个数。

从 $1$ 开始枚举 $i$，直到 $i$ 与 $i+1$ （其中的偶数除以二）的因数个数之积不少于 $500$。

```python
from sympy import factorint

def calFactors(x):
	if x % 2 == 0: x //= 2
	divs = factorint(x)
	num = 1
	for p in divs:
		num *= divs[p] + 1
	return num

if __name__ == '__main__':
	N = int(10 ** 5)
	for i in range(3, N):
		if calFactors(i) * calFactors(i - 1) >= 500:
			print(i * (i - 1) // 2)
			break
```

Answer: **76576500**

## Problem 13. [Large sum](https://projecteuler.net/problem=13)

求下列 $100$ 个 $50$ 位数之和的前 $10$ 位。

`37107287533902102798797998220837590246510135740250`
`46376937677490009712648124896970078050417018260538`
`74324986199524741059474233309513058123726617309629`
`91942213363574161572522430563301811072406154908250`
`23067588207539346171171980310421047513778063246676`
`89261670696623633820136378418383684178734361726757`
`28112879812849979408065481931592621691275889832738`
`44274228917432520321923589422876796487670272189318`
`47451445736001306439091167216856844588711603153276`
`70386486105843025439939619828917593665686757934951`
`62176457141856560629502157223196586755079324193331`
`64906352462741904929101432445813822663347944758178`
`92575867718337217661963751590579239728245598838407`
`58203565325359399008402633568948830189458628227828`
`80181199384826282014278194139940567587151170094390`
`35398664372827112653829987240784473053190104293586`
`86515506006295864861532075273371959191420517255829`
`71693888707715466499115593487603532921714970056938`
`54370070576826684624621495650076471787294438377604`
`53282654108756828443191190634694037855217779295145`
`36123272525000296071075082563815656710885258350721`
`45876576172410976447339110607218265236877223636045`
`17423706905851860660448207621209813287860733969412`
`81142660418086830619328460811191061556940512689692`
`51934325451728388641918047049293215058642563049483`
`62467221648435076201727918039944693004732956340691`
`15732444386908125794514089057706229429197107928209`
`55037687525678773091862540744969844508330393682126`
`18336384825330154686196124348767681297534375946515`
`80386287592878490201521685554828717201219257766954`
`78182833757993103614740356856449095527097864797581`
`16726320100436897842553539920931837441497806860984`
`48403098129077791799088218795327364475675590848030`
`87086987551392711854517078544161852424320693150332`
`59959406895756536782107074926966537676326235447210`
`69793950679652694742597709739166693763042633987085`
`41052684708299085211399427365734116182760315001271`
`65378607361501080857009149939512557028198746004375`
`35829035317434717326932123578154982629742552737307`
`94953759765105305946966067683156574377167401875275`
`88902802571733229619176668713819931811048770190271`
`25267680276078003013678680992525463401061632866526`
`36270218540497705585629946580636237993140746255962`
`24074486908231174977792365466257246923322810917141`
`91430288197103288597806669760892938638285025333403`
`34413065578016127815921815005561868836468420090470`
`23053081172816430487623791969842487255036638784583`
`11487696932154902810424020138335124462181441773470`
`63783299490636259666498587618221225225512486764533`
`67720186971698544312419572409913959008952310058822`
`95548255300263520781532296796249481641953868218774`
`76085327132285723110424803456124867697064507995236`
`37774242535411291684276865538926205024910326572967`
`23701913275725675285653248258265463092207058596522`
`29798860272258331913126375147341994889534765745501`
`18495701454879288984856827726077713721403798879715`
`38298203783031473527721580348144513491373226651381`
`34829543829199918180278916522431027392251122869539`
`40957953066405232632538044100059654939159879593635`
`29746152185502371307642255121183693803580388584903`
`41698116222072977186158236678424689157993532961922`
`62467957194401269043877107275048102390895523597457`
`23189706772547915061505504953922979530901129967519`
`86188088225875314529584099251203829009407770775672`
`11306739708304724483816533873502340845647058077308`
`82959174767140363198008187129011875491310547126581`
`97623331044818386269515456334926366572897563400500`
`42846280183517070527831839425882145521227251250327`
`55121603546981200581762165212827652751691296897789`
`32238195734329339946437501907836945765883352399886`
`75506164965184775180738168837861091527357929701337`
`62177842752192623401942399639168044983993173312731`
`32924185707147349566916674687634660915035914677504`
`99518671430235219628894890102423325116913619626622`
`73267460800591547471830798392868535206946944540724`
`76841822524674417161514036427982273348055556214818`
`97142617910342598647204516893989422179826088076852`
`87783646182799346313767754307809363333018982642090`
`10848802521674670883215120185883543223812876952786`
`71329612474782464538636993009049310363619763878039`
`62184073572399794223406235393808339651327408011116`
`66627891981488087797941876876144230030984490851411`
`60661826293682836764744779239180335110989069790714`
`85786944089552990653640447425576083659976645795096`
`66024396409905389607120198219976047599490197230297`
`64913982680032973156037120041377903785566085089252`
`16730939319872750275468906903707539413042652315011`
`94809377245048795150954100921645863754710598436791`
`78639167021187492431995700641917969777599028300699`
`15368713711936614952811305876380278410754449733078`
`40789923115535562561142322423255033685442488917353`
`44889911501440648020369068063960672322193204149535`
`41503128880339536053299340368006977710650566631954`
`81234880673210146739058568557934581403627822703280`
`82616570773948327592232845941706525094512325230608`
`22918802058777319719839450180888072429661980811197`
`77158542502016545090413245809786882778948721859617`
`72107838435069186155435662884062257473692284509516`
`20849603980134001723930671666823555245252804609722`
`53503534226472524250874054075591789781264330331690`

```python
x = 37107287533902102798797998220837590246510135740250 + 46376937677490009712648124896970078050417018260538 + 74324986199524741059474233309513058123726617309629 + 91942213363574161572522430563301811072406154908250 + 23067588207539346171171980310421047513778063246676 + 89261670696623633820136378418383684178734361726757 + 28112879812849979408065481931592621691275889832738 + 44274228917432520321923589422876796487670272189318 + 47451445736001306439091167216856844588711603153276 + 70386486105843025439939619828917593665686757934951 + 62176457141856560629502157223196586755079324193331 + 64906352462741904929101432445813822663347944758178 + 92575867718337217661963751590579239728245598838407 + 58203565325359399008402633568948830189458628227828 + 80181199384826282014278194139940567587151170094390 + 35398664372827112653829987240784473053190104293586 + 86515506006295864861532075273371959191420517255829 + 71693888707715466499115593487603532921714970056938 + 54370070576826684624621495650076471787294438377604 + 53282654108756828443191190634694037855217779295145 + 36123272525000296071075082563815656710885258350721 + 45876576172410976447339110607218265236877223636045 + 17423706905851860660448207621209813287860733969412 + 81142660418086830619328460811191061556940512689692 + 51934325451728388641918047049293215058642563049483 + 62467221648435076201727918039944693004732956340691 + 15732444386908125794514089057706229429197107928209 + 55037687525678773091862540744969844508330393682126 + 18336384825330154686196124348767681297534375946515 + 80386287592878490201521685554828717201219257766954 + 78182833757993103614740356856449095527097864797581 + 16726320100436897842553539920931837441497806860984 + 48403098129077791799088218795327364475675590848030 + 87086987551392711854517078544161852424320693150332 + 59959406895756536782107074926966537676326235447210 + 69793950679652694742597709739166693763042633987085 + 41052684708299085211399427365734116182760315001271 + 65378607361501080857009149939512557028198746004375 + 35829035317434717326932123578154982629742552737307 + 94953759765105305946966067683156574377167401875275 + 88902802571733229619176668713819931811048770190271 + 25267680276078003013678680992525463401061632866526 + 36270218540497705585629946580636237993140746255962 + 24074486908231174977792365466257246923322810917141 + 91430288197103288597806669760892938638285025333403 + 34413065578016127815921815005561868836468420090470 + 23053081172816430487623791969842487255036638784583 + 11487696932154902810424020138335124462181441773470 + 63783299490636259666498587618221225225512486764533 + 67720186971698544312419572409913959008952310058822 + 95548255300263520781532296796249481641953868218774 + 76085327132285723110424803456124867697064507995236 + 37774242535411291684276865538926205024910326572967 + 23701913275725675285653248258265463092207058596522 + 29798860272258331913126375147341994889534765745501 + 18495701454879288984856827726077713721403798879715 + 38298203783031473527721580348144513491373226651381 + 34829543829199918180278916522431027392251122869539 + 40957953066405232632538044100059654939159879593635 + 29746152185502371307642255121183693803580388584903 + 41698116222072977186158236678424689157993532961922 + 62467957194401269043877107275048102390895523597457 + 23189706772547915061505504953922979530901129967519 + 86188088225875314529584099251203829009407770775672 + 11306739708304724483816533873502340845647058077308 + 82959174767140363198008187129011875491310547126581 + 97623331044818386269515456334926366572897563400500 + 42846280183517070527831839425882145521227251250327 + 55121603546981200581762165212827652751691296897789 + 32238195734329339946437501907836945765883352399886 + 75506164965184775180738168837861091527357929701337 + 62177842752192623401942399639168044983993173312731 + 32924185707147349566916674687634660915035914677504 + 99518671430235219628894890102423325116913619626622 + 73267460800591547471830798392868535206946944540724 + 76841822524674417161514036427982273348055556214818 + 97142617910342598647204516893989422179826088076852 + 87783646182799346313767754307809363333018982642090 + 10848802521674670883215120185883543223812876952786 + 71329612474782464538636993009049310363619763878039 + 62184073572399794223406235393808339651327408011116 + 66627891981488087797941876876144230030984490851411 + 60661826293682836764744779239180335110989069790714 + 85786944089552990653640447425576083659976645795096 + 66024396409905389607120198219976047599490197230297 + 64913982680032973156037120041377903785566085089252 + 16730939319872750275468906903707539413042652315011 + 94809377245048795150954100921645863754710598436791 + 78639167021187492431995700641917969777599028300699 + 15368713711936614952811305876380278410754449733078 + 40789923115535562561142322423255033685442488917353 + 44889911501440648020369068063960672322193204149535 + 41503128880339536053299340368006977710650566631954 + 81234880673210146739058568557934581403627822703280 + 82616570773948327592232845941706525094512325230608 + 22918802058777319719839450180888072429661980811197 + 77158542502016545090413245809786882778948721859617 + 72107838435069186155435662884062257473692284509516 + 20849603980134001723930671666823555245252804609722 + 53503534226472524250874054075591789781264330331690
print(str(x)[:10])
```

Answer: **5537376230**

## Problem 14. [Longest Collatz sequence](https://projecteuler.net/problem=14)

对于 $x$，若 $x$ 是奇数，则 $x\rightarrow 3\times x+1$，若 $x$ 是偶数，则 $x\rightarrow x / 2$，一直重复该操作直到 $x=1$。

求 $[1,10^6]$ 中，从哪个数开始可以进行最多次操作。

枚举 $x$ ，用哈希表存储操作过程中每个数的答案，这是个有效剪枝。

```cpp
#include <bits/stdc++.h>

const int MAXN = 1e6 + 5;

std::map<long long, int> Ans;
std::vector<int> v;

int get(long long x) {
	v.clear();
	while (true) {
		v.push_back(x);
		if (x == 1 || Ans[x]) break;
		if (x % 2 == 0) x /= 2;
		else x = x * 3 + 1;
	}
	for (int i = v.size() - 2; i >= 0; --i) {
		Ans[v[i]] = Ans[v[i + 1]] + 1;
	}
	return Ans[v[0]];
}

int main() {
	int mx = 0, ans;
	for (int i = 2; i <= 1e6; ++i) {
		int t = get(i);
		if (t > mx) {
			ans = i;
			mx = t;
		}
	}
	printf("%d\n", ans);
	return 0;
}
```

Answer: **837799**

## Problem 15. [Lattice paths](https://projecteuler.net/problem=15)

在 $20\times 20$ 的网格图中，从左上角出发，每次可以往右或者往下走一格，求走到右下角的方案数。

组合数问题，即在$ 40$ 步中任选 $20$ 步向右，方案数为 $C^{20}_{40}=\frac{40!}{20!\times 20!}$。

```python
import math
if __name__ == '__main__':
	n = 20
	print(math.factorial(2 * n) // math.factorial(n) // math.factorial(n))
```

Answer: **137846528820**

## Problem 16. [Power digit sum](https://projecteuler.net/problem=16)

求 $2^{1000}$ 的每一位数字之和。

```python
if __name__ == '__main__':
	print(sum(int(i) for i in str(2**1000)))
```

Answer: **1366**

## Problem 17. [Number letter counts](https://projecteuler.net/problem=17)

求用英文单词写出 $1-1000$ 中所有数的字母数。

把数分解成每一位数字和and，分别求字母数。

```cpp
#include <bits/stdc++.h> 

std::string s[] = {"one", "two", "three", "four", "five", "six", "seven","eight", "nine", "ten"};
std::string s2[] = {"eleven", "twelve", "thirteen", "fourteen","fifteen","sixteen", "seventeen", "eighteen", "nineteen"};
std::string s3[] = {"twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"};
std::string s4[] = {"hundred", "thousand"};

std::string getX(int x, int type=0) {
	if (x == 0) return "";
	std::string ans("");
	if (x <= 10) {
		ans = s[x - 1];
	} else if (x < 20) {
		ans = s2[x - 11];
	} else if (x < 100) {
		int ten = x / 10, one = x % 10;
		ans = s3[ten - 2];
		if (one > 0) ans += " " + s[one - 1];
	}
	return !type ? ans : " and " + ans;
}

int get(int x) {
	std::string ans("");
	if (x >= 100) {
		int hundred = x / 100;
		ans = s[hundred - 1] + " " + s4[0];
		ans += getX(x % 100, 1);
	} else {
		ans = getX(x);
	}
	int cnt = 0;
	for (size_t i = 0; i < ans.length(); ++i)
		if (isalpha(ans[i])) ++cnt;
	return cnt;
}

int main() {
	int total = 11;
	for (int i = 1; i < 1000; ++i)
		total += get(i);
	printf("%d\n", total);
	return 0;
}
```

Answer: **21124**

## Problem 18. [Maximum path sum I](https://projecteuler.net/problem=18)

在一个如下数字金字塔中，从顶端出发，每次可以移动到相邻的左下或者右下方，求到达最下方的路径上数的最大和。

`75`
`95 64`
`17 47 82`
`18 35 87 10`
`20 04 82 47 65`
`19 01 23 75 03 34`
`88 02 77 73 07 63 67`
`99 65 04 28 06 16 70 92`
`41 41 26 56 83 40 80 70 33`
`41 48 72 33 47 32 37 16 94 29`
`53 71 44 65 25 43 91 52 97 51 14`
`70 11 33 28 77 73 17 78 39 68 17 57`
`91 71 52 38 17 14 91 43 58 50 27 29 48`
`63 66 04 68 89 53 67 30 73 16 69 87 40 31`
`04 62 98 27 23 09 70 98 73 93 38 53 60 04 23`

动态规划：$f(i,j) = \max(f(i-1,j),f(i-1,j-1))+a(i,j)$。

```cpp
#include <bits/stdc++.h>

int A[15][15] = {
{75},
{95,64},
{17,47,82},
{18,35,87,10},
{20,4,82,47,65},
{19,1,23,75,3,34},
{88,2,77,73,7,63,67},
{99,65,4,28,6,16,70,92},
{41,41,26,56,83,40,80,70,33},
{41,48,72,33,47,32,37,16,94,29},
{53,71,44,65,25,43,91,52,97,51,14},
{70,11,33,28,77,73,17,78,39,68,17,57},
{91,71,52,38,17,14,91,43,58,50,27,29,48},
{63,66,4,68,89,53,67,30,73,16,69,87,40,31},
{4,62,98,27,23,9,70,98,73,93,38,53,60,4,23}};

int F[15][15];

int main() {
	F[0][0] = A[0][0];
	for (int i = 1; i < 15; ++i) {
		F[i][0] = F[i - 1][0] + A[i][0];
		for (int j = 1; j <= i; ++j) 
			F[i][j] = std::max(F[i - 1][j], F[i - 1][j - 1]) + A[i][j];
	}
	int mx = 0;
	for (int i = 0; i < 15; ++i) mx = std::max(mx, F[14][i]);
	printf("%d\n", mx);
	return 0;
}
```

Answer: **1074**

## Problem 19. [Special Pythagorean triplet](https://projecteuler.net/problem=19)

已知1900年1月1日是周一，求20世纪有多少月的第一天是周日。

枚举每个月首，通过计算距离1900年1月1日的日期数，判断是否为周末。

```cpp
#include <bits/stdc++.h>

int Days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

bool isLeap(int year) {
	return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
}

int get(int year, int month, int day) {
	int num = 0;
	for (int i = 1900; i < year; ++i) {
		num += 365 + isLeap(i);
	}
	for (int i = 1; i < month; ++i) {
		if (i == 2 && isLeap(year)) ++num;
		num += Days[i];
	}
	num += day;
	return num % 7;
}

int main() {
	int num = 0;
	for (int i = 1901; i <= 2000; ++i) {
		for (int j = 1; j <= 12; ++j) {
			num += !get(i, j, 1);
		}
	}
	printf("%d\n", num);
	return 0;
}
```

Answer: **171**

## Problem 20. [Factorial digit sum](https://projecteuler.net/problem=20)

求 $100!$ 的各位数字之和。

```python
import math
if __name__ == '__main__':
	result = 0
	for i in str(math.factorial(100)):
		result = result + int(i)
	print(result)
```

Answer: **648**